# Css设计原则


#### OOCSS方法
```css
<div class="toggle simple">
    <div class="toggle-control open">
        <h1 class="toggle-title">Title 1</h1>
    </div>
    <div class="toggle-details open"> ... </div>
    ...
</div>
```
- 分离结构和外观：根据外观来写类样式，当前的“simple”皮肤使用直角，而“complex”皮肤可能使用圆角，还加了阴影。
- 分离容器和内容：根据内容来写类样式，并且是可叠加的，不同的类使该元素的样式有不一样的变化。

#### SMACSS方法（模块化架构的可扩展css）
根据功能把类分为五种：基础（可用于叠加的css类）、布局、模块（一般指功能型组件）、状态（表示当前组件状态）、主题（具备换肤功能）。
```css
<div class="toggle toggle-simple">
    <div class="toggle-control is-active">
        <h2 class="toggle-title">Title 1</h2>
    </div>
    <div class="toggle-details is-active">
    ...
    </div>
    ...
</dl>
```

#### BEM方法（块元素修饰符）只是一个命名规则
每一个类名都包含
- 块名：所属组件的名称。
- 元素：元素在块里面的名称。
- 修饰符：任何与块或元素相关联的修饰符。
```css
<div class="toggle toggle--simple">
    <div class="toggle__control toggle__control--active">
        <h2 class="toggle__title">Title 1</h2>
    </div>
    <div class="toggle__details toggle__details--active">
    ...
    </div>
    ...
</dl>
```

#### 可以使用以上方案来避免CSS中的一些问题
- 选择器优先级、颜色重置、位置依赖、多重继承、深层嵌套。
- 单一样式来源：写样式的时候，携带上下文一起写，这样就算转移代码也可以整块转移，保证样式不变。
- 组件修饰符：使用传统的 BEM 语法创建了 calendar--nested 修饰符。这个 CSS类名单独使用时什么都不做，而当它被应用到日历组件上时，组件里的元素就能拿它做局部上下文并改变外观

- 分离容器和内容
- 区分布局与组件的角色和职责
- 在标记上使用单一、扁平的选择器
- 使用其他原则，比如单一职责原则、单一样式来源、内容修饰符





# Js书写原则
使用精简的方案做项目，而不是一开始就使用一大套工具和大规模的启动页。除非增加复杂度和代码体积利大于弊，否则不要轻易放弃精简方案。

- 保持代码整洁：
使用JS Hint  或者 ESLint 之类的代码检查工具
- 创造可复用的函数：
```js
$.fn.log_text_on_click = function() {
    this.on('click', function() {
        console.log($(this).html());
    });
    return this;
};
$.fn.add_background = function(color) {
    this.css('background-color', color);
    return this;
}
$('.red-alert').add_background("red").log_text_on_click();
$('.yellow-alert').add_background("yellow").log_text_on_click();
```



# 流程核心


#### 前端工作流
- 必要的工具：git、eslint、配置服务器等等
- 本地部署：如何使项目部署并且运转
- 编写任务：通过关注组件而非单页面的内容，我们可以保证优先考虑的是设计系统，以及改动对系统产生的影响。这样的方式创建了一个更具弹性的系统，有助于避免多个页面之间的冲突

#### 在任务处理器中完成一切
- 清理临时文件夹
- 创建软连接
- 编译 Sass
- 合并 JavaScript
- 加载第三方 JavaScript 库
- 把 SVG 文件编译成图标字体
- 对图片进行处理，减少文件体积，裁剪成各种尺寸
- 同步文件到远程服务器
- 创建 Git 标签
- 运行可视化的回归测试
- 生成代码的样式文档
- 自动生成浏览器厂商的前缀
- 编译组件库
- 优化我的 Stylus、CSS、JavaScript、JSON，等等
- 基于 JSON 模式来验证数据
- 启动 Node服务器监听文件改动来刷新浏览器



# 设计原则


#### 过渡依赖
不要让转移其中某一块内容变得很困难。
#### 严重的位置依赖
组件化开发，将样式也变为组件化。
#### 设计分解
不同的板块使用不同的sass文件。我们的首要任务是把设计分解成尽可能小的单位。我们知道，一旦有了建造设计系统的基本构件，就可以创造任何视觉语言所能传达的东西。所以第一步就是细看我们的设计，并且把它分解为可复用的布局模式。
#### 组件分类
分解设计，之后使用更小的组件来组建布局
#### 编写自己的规则
只包含不可变的规则，而不是笼统的说明
总是把规则提炼成最简单的表达
总是先说明规则是什么，在说明“如果不这样，会如何”
每个规则必须包含以下词中的一个——总是、永远不要、只有、每一个、不要、要
#### 设计系统的规则
- 永远不要给布局的子内容强加内边距和元素样式。布局只关注垂直对齐、水平对齐和文
字间距。
- 主题和别的数据属性值永远不要强制改变外观；它们必须保持布局、组件和元素可以应
用于其上。
- 组件总是贴着它的父容器的四个边，元素都没有上外边距和左外边距，所有的最后节点
（最右边和最下边的节点）的外边距都会被清除。
- 组件本身永远不要添加背景、宽度、浮动、内边距和外边距的样式，组件样式是组件内
元素的样式。
- 每个元素都有且只有一个唯一的且作用域只在组件内的 css 类名。所有的样式都是直
接应用到这个选择器上，并且只有上下文和主题能修改元素的样式。
- 永远不要在元素上使用上外边距，第一个元素总是贴着它所在组件的顶部。
- JavaScript 永远不要绑定任何元素的 css 类名，选中元素通过数据属性实现。
#### 每个标签指定唯一的选择器
- 不要总想制造万能的css类
- 单一责任原则，每个css类都有一个简单高度聚焦的责任，所以在某个场景下，用一个 css 类来设置元素的盒模型的属性，另一个设置排版，还有一个设置背景和颜色。确保每个 css 类只为一个目的创建。
- 样式只有单一来源，修饰符与上下文对标签样式的任何改变都会和标签的原始样式定义在同一个地方，而不会分散在不同文件。

#### 可选的修饰符
CSS 类的属性都是一维的：应用状态或非应用状态。而数据属性是二维的，有数据属性本身和通过它传递的值。为了补偿 CSS类缺少的维度，你会经常发现 CSS 类会使用命名空间来定义该标签属于哪个分组
```css
<!-- card.scss -->
.rh-card--layout {
    padding: 30px;
    &[data-rh-theme="light"]{
        background: white;
    }
    &[data-rh-theme="dark"]{
        background: black;
    }
   &[data-rh-justify="center"]{
    ...
   }
   &[data-rh-justify="top"]{
    ...
   }
   &[data-rh-justify="justify"]{
    ...
   }
}
```

#### 可选的上下文
一个组件无论放在哪里，都呈现一样的外观。但我们希望组件不仅可控并具有一致性，而且智能和灵活。这就是我们想出了上下文样式的原因。组件可以根据所在的父级元素或者父级元素的某些数据属性来改变自身的表现。
- 父级容器的皮肤属性`[data-rh-theme~="dark"]`变为`[data-rh-theme~="light"]`,子级元素的样式也随之改变
- 父级容器的数据属性 data-rh-layout的值从gallery5变为了gallery4，布局就从五列变为四列


# 项目优化
> 网站性能最基本的测试是看渲染页面所需要的资源，包括这些资源的大小和总数。

#### 页面大小
当你希望缩减页面的大小时，可以从以下几个显而易见的地方开始。
- 图片占据页面平均大小的 61%。
    - 优化 PNG 图片，并降低 JPEG 图片的质量。
    - 利用新的响应式的 <picture> 标记和 srcset 属性来下载大小合适的图片。
    - 制定一个预算，如果没有移除任何图片，就不增加图片大小。
- 太多自定义字体很快会使网页变得臃肿。
    - 制定一个字体预算，不考虑增加第二种或第三种字体。
    - 考虑必要的字体粗细，因为每增加一种粗细变化，都会使字体文件增加几千个字节。
    - 虽然图标字体很不错，但要注意文件大小，因为图标字体会使字体文件迅速变大。如果一个网站只使用字体文件的一部分，其他网站使用另外的部分，那就拆分字体文件。也可以考虑使用内联 SVG 代替图标字体，只加载需要的 SVG 就可以得到很多图标字体了。
- JavaScript 框架、jQuery 插件和 CSS 框架常常使页面大小增加很多，却收效甚微。
    - 很多网站都已远离 jQuery，因为 vanilla JS 就可以满足其需求，尤其是网站只针对现代浏览器时。
    - jQuery 插件虽然可能会提供一些很厉害的功能，却常常使页面大小显著增加。考虑在现代浏览器上使用 CSS 能否达到同样的效果，并在低版本浏览器上合理地回退。
    - 像 Angular 或者 Ember 这样的大型 JavaScript 框架也许能完成你的工作，但生成的网页大小会超出实际工作的需要。如果只需要使用 Angular 的视图层，那么最好使用React 或 Mustache 来替换。
    - CSS 框架往往是乱七八糟的。它包含可能会用到的所有想象得到的样式。虽然这对于网页快速成型很有帮助，但从现有的几千字节的CSS和JavaScript出发来构建网站，会让你在开始写第一行代码之前就陷入困境。
- 使用压缩
    - JavaScript 可以在构建流程中以编程的方式进行压缩，而且可以在服务器将文件发送到浏览器之前使用 gzip 压缩。这些都是缩减网页大小的关键步骤。
 

#### Http请求次数
- 减少 HTTP 请求的次数。
    - 不要提供数十个单独的 CSS 文件和 JavaScript 文件，而是把它们合并到一个文件中。
    - 把多个单独的图像文件合并成一个图像映射或者图标字体。有很多不错的工具（例如 Compass 和 Grunt/Gulp 插件）可以帮你自动化地完成这些任务。
    - 延迟加载页面最初加载所不需要的资源。这可能是直到用户与页面交互才需要的JavaScript 文件，也可能是初始加载窗口之下距离较远的图片。
- 增加浏览器每次并发请求的资源个数。
    - 分拆你的资源到不同的服务器（或者 CDN），可以使得浏览器单次并发下载更多的资源，因为浏览器的并发请求数量限制是针对单个服务器的。

#### 计时度量
- 首字节时间
- 开始渲染时间
- 文档完成时间



