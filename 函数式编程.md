# 函数式编程
- 函数的关键点
  1. 函数必须总是接受一个参数
  2. 函数必须总是返回一个值
  3. 函数应该依据接受到的参数而不是外部环境
  4. 对于一个给定的X, 只会输出唯一的一个Y

- 函数式编程是一种范式, 仅依赖输入就可以完成自身逻辑的函数
- 函数不会改变任何外部环境的变量,这将产生可缓存的,可测试的代码库

```js
/* 引用透明性*/ 
// 所有函数对于相同的输入都将返回相同的值, 函数的这个属性被称为引用透明性
let identity = (i)=>{return i}
sum(4,5) + identity(1)
// 等价于
sum(4,5) + 1
// 该过程被称为替换模型,因为identity的逻辑不依赖其他变量,使得并发代码和缓存成为可能
// 例如一个用于计算阶乘的函数, 如果在第二次算5的阶乘时就可以使用第一次缓存的结果
```

### 纯函数
- 纯函数是对给定的输入返回相同的输出的函数
- 纯函数不应该依赖任何外部变量,也不应该更改任何外部变量
- 纯函数可以真正的并发的执行函数, 使用形参来代替全局参数

- 纯函数可以被缓存
```js
function keeperRunin(){
    // 执行长时间的任务并返回
}
var keeper = { 2:3, 4:5 }
keeper.hasOwnProperty(ip)?
    keeper[ip]:
    keeper[ip] = keeperRunin(ip)
```

- 纯函数应该被设计制作一件事,只做一件事并做到完美是unix的哲学
- 组合式命令完成复杂的任务,称为函数式组合
- 尽量使用js的严格模式
- 函数也可作为js的一种数据类型
- 高阶函数是接受函数作为参数并且/或者返回函数作为输出的函数
```js
// es6-functional.js
const forEach = (array,fn)=>{
    let i ;
    for(i=0;i<array.length;i++)
        fn(array[i])
}
const forEachObject = (obj,fn)=>{
    for(var property in object){
        if(obj.hasOwnProperty(property)){
            // 以key和value作为参数调用fn
            fn(property,obj[property])
        }
    }
}
export default forEach

// application.js
import forEach from 'es6-functional.js'
var array = [1,2,3]
forEach(array,(data)=>{console.log(data)})
```


### 抽象
- 抽象让我们专注于预定的目标而无须关心底层的系统概念

```js
// 打印数组中偶数
const unless = (predicate,fn)=>{
    if(!predicate){
        fn()
    }
}
forEach([1,2,3,4,5],(number)=>{
    unless(number % 2,()=>{
        console.log(number,'is even')
    })
})

// 打印[1,...,100]的偶数
const times = (timers,fn)=>{
    for(var i=0;i<times;i++)
        fn(i)
}
times(100,function(n){
    unless(n % 2,function(){
        console.log(n, 'is even')
    })
})
// 抽象出循环,条件判断被放在一个简明的高阶函数
```

### 高阶函数
```js
/* 检查数组的内容是否为一个数字,自定义对象,或其他类型 */ 
const every = (arr,fn)=>{
    let result = true;
    for(let i=0;i<arr.length;i++)
        result = result && fn(arr[i])
    // for(const value of arr)
    //     result = result && fn(value)
    return result
}
every([NaN,NaN,NaN],isNaN)  //true
every([NaN,NaN,4],isNaN)    //false

/* 如果数组中的一个元素通过传入的函数返回true,函数就返回true */
const some = (arr, fn)=>{
    let result = false;
    for(const value of arr)
        result = result || fn(value)
    return result
}
some([NaN,NaN,4],isNaN) //true
some([1,2,4],isNaN)     //false
// every和some函数都是低效的实现,遇到大数组会比较费劲

/* 根据属性来对数组项进行排序 */
const sortBy = (property)=>{
    return (a,b)=>{
        var result = (a[property]<b[property])?-1:(a[property]>b[property])?1:0
    }
}
let people = [
    {firstname:'aaa',lastname:'ccc'},
    {firstname:'aaa',lastname:'ccc'},
    {firstname:'aaa',lastname:'ccc'}
]
people.sort(sortBy('firstname'))
people.sort(sortBy('lastname'))
```

